import {
  type Context,
  type EntityId,
  EventType,
  hasComponent,
  createEntity,
  addComponent,
  removeComponent,
} from "@infinitecanvas/ecs";

import {
  SINGLETON_STABLE_ID,
  type Mutation,
  type Patch,
  type ComponentData,
} from "../types";
import { Origin } from "../constants";
import type { AnyEditorComponentDef } from "../EditorComponentDef";
import type { AnyEditorSingletonDef } from "../EditorSingletonDef";
import { Synced } from "../Synced";
import { diffFields } from "../diff";
import type { Adapter } from "../Adapter";

export interface EcsAdapterOptions {
  components: AnyEditorComponentDef[];
  singletons: AnyEditorSingletonDef[];
}

/**
 * ECS bridge that converts ECS events to mutations and vice versa.
 *
 * - pull(): Reads ECS events and produces mutations with stable ID keys.
 * - push(): Receives mutations and applies them to the ECS context.
 *
 * Circular updates are avoided by only reading events that occurred
 * between when push() finishes and the next pull() starts. Events
 * generated by push() writing to the ECS are skipped by advancing
 * the event index after push completes.
 */
export class EcsAdapter implements Adapter {
  ctx!: Context;
  private components: AnyEditorComponentDef[];
  private singletons: AnyEditorSingletonDef[];

  /** componentId -> definition (built during initialize) */
  private componentMap = new Map<
    number,
    AnyEditorComponentDef | AnyEditorSingletonDef
  >();

  /** component name -> definition */
  private componentsByName = new Map<
    string,
    AnyEditorComponentDef | AnyEditorSingletonDef
  >();

  /** stable UUID -> ECS entity ID */
  private stableIdToEntity = new Map<string, EntityId>();

  /** ECS entity ID -> stable UUID */
  private entityToStableId = new Map<EntityId, string>();

  /** Previously synced state for computing diffs */
  private prevState: Record<string, ComponentData> = {};

  /** Event buffer read position */
  private eventIndex = 0;

  private initialized = false;

  constructor(options: EcsAdapterOptions) {
    this.components = options.components;
    this.singletons = options.singletons;
  }

  async init(): Promise<void> {
    // No async initialization needed
  }

  /**
   * Build component lookup maps on first pull.
   */
  private ensureInitialized(): void {
    if (this.initialized) return;
    this.initialized = true;

    const ctx = this.ctx;
    for (const comp of [...this.components, ...this.singletons]) {
      if (comp.__sync === "none") continue;

      const componentId = comp._getComponentId(ctx);
      this.componentMap.set(componentId, comp);
      this.componentsByName.set(comp.name, comp);
    }
    this.eventIndex = ctx.eventBuffer.getWriteIndex();
  }

  /**
   * Read ECS events since the last push and convert to mutations.
   * Keys use stable IDs: "uuid/componentName" or "SINGLETON/singletonName".
   */
  pull(): Mutation | null {
    this.ensureInitialized();
    const ctx = this.ctx;
    const { events } = ctx.eventBuffer.readEvents(this.eventIndex);

    if (events.length === 0) return null;

    const patch: Patch = {};

    for (const event of events) {
      const { entityId, eventType, componentId } = event;

      // Handle entity removal — emit deletion patches for all tracked components
      if (eventType === EventType.REMOVED) {
        let stableId = this.entityToStableId.get(entityId);

        if (!stableId) continue;

        const prefix = `${stableId}/`;
        for (const key of Object.keys(this.prevState)) {
          if (key.startsWith(prefix)) {
            patch[key] = { _exists: false };
            this.prevState[key] = { _exists: false };
          }
        }

        this.stableIdToEntity.delete(stableId);
        this.entityToStableId.delete(entityId);
        continue;
      }

      const componentDef = this.componentMap.get(componentId);

      if (!componentDef) continue;

      // exclude unsynced entities
      if (
        !componentDef.isSingleton &&
        !hasComponent(ctx, entityId, Synced, false)
      )
        continue;

      const synced = Synced.read(ctx, entityId);

      // Resolve stable ID
      let stableId: string;
      if (componentDef.isSingleton) {
        stableId = SINGLETON_STABLE_ID;
      } else {
        stableId = synced.id;
        this.stableIdToEntity.set(stableId, entityId);
        this.entityToStableId.set(entityId, stableId);
      }

      const key = `${stableId}/${componentDef.name}`;

      switch (eventType) {
        case EventType.COMPONENT_ADDED: {
          if (componentDef.isSingleton) continue;
          const data = componentDef.snapshot(ctx, entityId);
          patch[key] = { _exists: true, ...data };
          this.prevState[key] = { ...data };
          break;
        }

        case EventType.COMPONENT_REMOVED: {
          if (componentDef.isSingleton) continue;
          patch[key] = { _exists: false };
          this.prevState[key] = { _exists: false };
          break;
        }

        case EventType.CHANGED: {
          const data = componentDef.isSingleton
            ? (componentDef as AnyEditorSingletonDef).snapshot(ctx)
            : componentDef.snapshot(ctx, entityId);

          const prev = this.prevState[key] ?? { _exists: false };
          const changes = diffFields(prev, data);
          if (!changes) continue;

          patch[key] = changes as ComponentData;
          this.prevState[key] = { ...data };
          break;
        }
      }
    }

    if (Object.keys(patch).length > 0) {
      return { patch, origin: Origin.ECS };
    }

    return null;
  }

  /**
   * Apply mutations to the ECS context.
   * Self-originated mutations (origin ECS) are skipped — the ECS world
   * already contains those changes from the current frame.
   * After applying, advances the event index to skip any events
   * generated by these writes.
   */
  push(mutations: Mutation[]): void {
    const ctx = this.ctx;
    for (const { patch, origin } of mutations) {
      if (origin === Origin.ECS) continue;
      for (const [key, value] of Object.entries(patch)) {
        const sepIndex = key.indexOf("/");
        const stableId = key.slice(0, sepIndex);
        const componentName = key.slice(sepIndex + 1);

        const componentDef = this.componentsByName.get(componentName);
        if (!componentDef) continue;

        if (stableId === SINGLETON_STABLE_ID) {
          if (value._exists === false) continue; // Singletons can't be removed
          (componentDef as AnyEditorSingletonDef).patch(ctx, value as any);
          this.prevState[key] = { ...this.prevState[key], ...value };
          continue;
        }

        // Entity component
        let entityId = this.stableIdToEntity.get(stableId);

        if (value._exists === false) {
          // Remove component
          if (
            entityId !== undefined &&
            hasComponent(
              ctx,
              entityId,
              componentDef as AnyEditorComponentDef,
              false,
            )
          ) {
            removeComponent(
              ctx,
              entityId,
              componentDef as AnyEditorComponentDef,
            );
          }
          this.prevState[key] = { _exists: false };
        } else if (value._exists) {
          // Add component (create entity if needed)
          const { _exists, ...data } = value;

          if (entityId === undefined) {
            entityId = createEntity(ctx);
            addComponent(ctx, entityId, Synced, { id: stableId });
            this.stableIdToEntity.set(stableId, entityId);
            this.entityToStableId.set(entityId, stableId);
          }

          if (
            hasComponent(
              ctx,
              entityId,
              componentDef as AnyEditorComponentDef,
              false,
            )
          ) {
            (componentDef as AnyEditorComponentDef).copy(
              ctx,
              entityId,
              data as any,
            );
          } else {
            addComponent(
              ctx,
              entityId,
              componentDef as AnyEditorComponentDef,
              data as any,
            );
          }
          this.prevState[key] = { ...data };
        } else {
          // Partial update — only touch specified fields
          if (
            entityId !== undefined &&
            hasComponent(
              ctx,
              entityId,
              componentDef as AnyEditorComponentDef,
              false,
            )
          ) {
            (componentDef as AnyEditorComponentDef).patch(
              ctx,
              entityId,
              value as any,
            );
            this.prevState[key] = { ...this.prevState[key], ...value };
          }
        }
      }
    }

    // Advance past events generated by our writes
    this.eventIndex = ctx.eventBuffer.getWriteIndex();
  }

  close(): void {
    // No resources to clean up
  }
}
